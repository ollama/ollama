package config

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/ollama/ollama/api"
	"github.com/ollama/ollama/progress"
)

// Vim implements the Runner interface for ollama launch vim integration.
// It provides zero-config Vim integration with Ollama using gergap/vim-ollama.
type Vim struct {
	model string
	host  string
	args  []string // pass-through args to vim
}

func (v *Vim) String() string {
	return "Vim with Ollama integration"
}

// Run implements the Runner interface.
// It configures the vim plugin and launches vim with the selected model.
func (v *Vim) Run(model string, args []string) error {
	v.model = model
	v.args = args

	// 1. Get host from OLLAMA_HOST or default
	v.host = os.Getenv("OLLAMA_HOST")
	if v.host == "" {
		v.host = "http://127.0.0.1:11434"
	}

	// 2. Ensure vim is available
	vimPath, err := v.detectVim()
	if err != nil {
		return fmt.Errorf("vim not found: %w", err)
	}

	// 3. Auto-pull model if needed
	ctx := context.Background()
	if err := v.ensureModel(ctx, model); err != nil {
		return fmt.Errorf("failed to ensure model %s: %w", model, err)
	}

	// 4. Ensure plugin is installed
	if err := v.ensurePlugin(); err != nil {
		return fmt.Errorf("failed to setup vim plugin: %w", err)
	}

	// 5. Write config files (auto-load without .vimrc edits)
	if err := v.writeConfig(); err != nil {
		return fmt.Errorf("failed to write vim config: %w", err)
	}

	// 6. Launch vim
	return v.launchVim(vimPath)
}

// detectVim finds vim executable, preferring vim over nvim
func (v *Vim) detectVim() (string, error) {
	candidates := []string{"vim", "vi"}
	
	for _, cmd := range candidates {
		if path, err := exec.LookPath(cmd); err == nil {
			return path, nil
		}
	}
	
	return "", fmt.Errorf("vim not found in PATH")
}

// ensureModel checks if model exists and pulls if missing
func (v *Vim) ensureModel(ctx context.Context, model string) error {
	client, err := api.ClientFromEnvironment()
	if err != nil {
		return err
	}

	// Check if model exists
	_, err = client.Show(ctx, &api.ShowRequest{Model: model})
	if err == nil {
		return nil // Model exists
	}

	// Model missing - pull it
	fmt.Fprintf(os.Stderr, "\nDownloading %s...\n", model)

	req := &api.PullRequest{
		Model: model,
	}

	bars := make(map[string]*progress.Bar)
	return client.Pull(ctx, req, func(p api.ProgressResponse) error {
		if p.Digest != "" {
			bar, ok := bars[p.Digest]
			if !ok {
				msg := p.Status
				if msg == "" {
					msg = fmt.Sprintf("pulling %s...", p.Digest[7:19])
				}
				bar = progress.NewBar(msg, p.Total, p.Completed)
				bars[p.Digest] = bar
			}
			bar.Set(p.Completed)
		}
		return nil
	})
}

// ensurePlugin installs vim-ollama plugin to ~/.vim/pack/ollama/start/
func (v *Vim) ensurePlugin() error {
	pluginDir := filepath.Join(os.Getenv("HOME"), ".vim", "pack", "ollama", "start", "vim-ollama")
	
	// Check if already installed
	if _, err := os.Stat(pluginDir); err == nil {
		// Plugin exists - could check for updates, but skip for now
		return nil
	}

	// Need to install - use git clone
	parentDir := filepath.Dir(pluginDir)
	if err := os.MkdirAll(parentDir, 0755); err != nil {
		return fmt.Errorf("failed to create plugin directory: %w", err)
	}

	fmt.Fprintf(os.Stderr, "Installing vim-ollama plugin...\n")
	
	cmd := exec.Command("git", "clone", "https://github.com/gergap/vim-ollama.git", pluginDir)
	cmd.Stderr = os.Stderr
	
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to clone vim-ollama: %w", err)
	}

	return nil
}

// writeConfig writes vim configuration files for auto-load
func (v *Vim) writeConfig() error {
	// Ensure directories exist
	vimConfigDir := filepath.Join(os.Getenv("HOME"), ".vim", "config")
	vimPluginDir := filepath.Join(os.Getenv("HOME"), ".vim", "plugin")
	
	for _, dir := range []string{vimConfigDir, vimPluginDir} {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Write main config file (user-editable settings)
	configPath := filepath.Join(vimConfigDir, "ollama.vim")
	configContent := fmt.Sprintf(`" Ollama configuration generated by ollama launch vim
let g:ollama_host = '%s'
let g:ollama_model = '%s'
let g:ollama_edit_model = '%s'
let g:ollama_chat_model = '%s'
let g:ollama_enabled = 1

" Auto-enable on startup
autocmd VimEnter * call ollama#Enable()
`, v.host, v.model, v.model, v.model)

	// Backup existing if present
	if err := v.backupIfExists(configPath); err != nil {
		return err
	}
	
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	// Write auto-load plugin (sources the config)
	pluginPath := filepath.Join(vimPluginDir, "ollama-launch.vim")
	pluginContent := `" Auto-generated by ollama launch vim
" Sources vim-ollama configuration without .vimrc edits

if !exists('g:ollama_enabled')
  let g:ollama_enabled = 1
endif

" Source user configuration
if filereadable(expand('~/.vim/config/ollama.vim'))
  source ~/.vim/config/ollama.vim
endif

" Auto-start completion on first insert mode
autocmd InsertEnter * once call ollama#SetupCompletion()
`

	// Backup existing if present
	if err := v.backupIfExists(pluginPath); err != nil {
		return err
	}

	if err := os.WriteFile(pluginPath, []byte(pluginContent), 0644); err != nil {
		return fmt.Errorf("failed to write plugin: %w", err)
	}

	return nil
}

// backupIfExists creates a .bak.timestamp backup of existing files
func (v *Vim) backupIfExists(path string) error {
	if _, err := os.Stat(path); err == nil {
		timestamp := fmt.Sprintf("%d", os.Getpid())
		backupPath := path + ".bak." + timestamp
		
		content, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read existing file: %w", err)
		}
		
		if err := os.WriteFile(backupPath, content, 0644); err != nil {
			return fmt.Errorf("failed to create backup: %w", err)
		}
		
		fmt.Fprintf(os.Stderr, "Backed up existing config to %s\n", backupPath)
	}
	return nil
}

// launchVim starts vim with the prepared configuration
func (v *Vim) launchVim(vimPath string) error {
	fmt.Fprintf(os.Stderr, "\nðŸš€ Launching Vim with Ollama integration...\n")
	fmt.Fprintf(os.Stderr, "   Model: %s\n", v.model)
	fmt.Fprintf(os.Stderr, "   Host:  %s\n", v.host)
	fmt.Fprintf(os.Stderr, "\nPlugin commands:\n")
	fmt.Fprintf(os.Stderr, "   <Tab>       - Accept completion\n")
	fmt.Fprintf(os.Stderr, "   :OllamaChat - Start chat\n")
	fmt.Fprintf(os.Stderr, "   :OllamaEdit - Edit with AI\n\n")

	args := v.args
	if len(args) == 0 {
		// Default: open current directory or empty
		args = []string{"."}
	}

	cmd := exec.Command(vimPath, args...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = os.Environ()

	// Set OLLAMA_HOST in environment
	cmd.Env = append(cmd.Env, fmt.Sprintf("OLLAMA_HOST=%s", v.host))

	return cmd.Run()
}

// Uninstall removes the vim integration files
func (v *Vim) Uninstall() error {
	dirs := []string{
		filepath.Join(os.Getenv("HOME"), ".vim", "pack", "ollama"),
		filepath.Join(os.Getenv("HOME"), ".vim", "config", "ollama.vim"),
		filepath.Join(os.Getenv("HOME"), ".vim", "plugin", "ollama-launch.vim"),
	}

	for _, path := range dirs {
		if err := os.RemoveAll(path); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: failed to remove %s: %v\n", path, err)
		}
	}

	fmt.Fprintf(os.Stderr, "Vim Ollama integration uninstalled\n")
	return nil
}
