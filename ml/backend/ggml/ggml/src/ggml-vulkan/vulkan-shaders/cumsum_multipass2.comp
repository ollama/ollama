#version 450

#include "types.glsl"
#include "sum_rows.glsl"

#extension GL_EXT_control_flow_attributes : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_basic : enable

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer A {A_TYPE data_a[];};
layout (binding = 1) buffer D {D_TYPE data_d[];};
layout (binding = 2) readonly buffer T {D_TYPE data_t[];};

layout (constant_id = 0) const uint BLOCK_SIZE = 128;
layout (constant_id = 1) const uint SUBGROUP_SIZE = 32;

#define CEIL_DIV(a, b) (((a) + (b) - 1) / (b))

shared FLOAT_TYPE temp[BLOCK_SIZE / SUBGROUP_SIZE];

void main() {
    const uint row = gl_WorkGroupID.y;
    const uint tid = gl_LocalInvocationID.x;

    const uint i03 = fastdiv(row, p.ne0_12mp, p.ne0_12L);
    const uint i03_offset = i03 * p.ne01*p.ne02;
    const uint i02 = fastdiv(row - i03_offset, p.ne0_1mp, p.ne0_1L);
    const uint i01 = row - i03_offset - i02*p.ne01;

    const uint src_idx = get_aoffset() + i01 * p.nb01 + i02 * p.nb02 + i03 * p.nb03;
    const uint dst_idx = get_doffset() + i01 * p.nb11 + i02 * p.nb12 + i03 * p.nb13;

    const uint col = gl_GlobalInvocationID.x;

    float v = 0;
    // prefetch value we're adding to
    if (col < p.n_cols) {
        v = data_d[dst_idx + col];
    }

    // compute the sum of all previous blocks
    uint c = tid;
    float sum = 0;
    while (c < gl_WorkGroupID.x) {
        sum += data_t[c + gl_NumWorkGroups.x * row];
        c += BLOCK_SIZE;
    }

    sum = subgroupAdd(sum);
    if (gl_SubgroupInvocationID == 0) {
        temp[gl_SubgroupID] = sum;
    }
    barrier();
    sum = 0;
    [[unroll]] for (uint s = 0; s < BLOCK_SIZE / SUBGROUP_SIZE; ++s) {
        sum += temp[s];
    }

    // Add the sum to what the first pass computed
    if (col < p.n_cols) {
        data_d[dst_idx + col] = v + sum;
    }
}

