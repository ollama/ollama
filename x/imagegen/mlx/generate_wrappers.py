#!/usr/bin/env python3
"""
Generate MLX-C dynamic loading wrappers.
Parses headers and generates mlx_wrappers.h with dlopen/dlsym support.
"""

import sys
import os
import re
import glob

def find_headers(directory):
    """Find all .h files in the directory"""
    pattern = os.path.join(directory, '**', '*.h')
    return glob.glob(pattern, recursive=True)

def clean_content(content):
    """Remove comments and preprocess directives"""
    # Remove single-line comments
    content = re.sub(r'//.*?$', '', content, flags=re.MULTILINE)
    # Remove multi-line comments
    content = re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)
    # Remove preprocessor directives
    content = re.sub(r'^\s*#.*?$', '', content, flags=re.MULTILINE)
    # Collapse whitespace and newlines
    content = re.sub(r'\s+', ' ', content)
    return content

def extract_param_names(params):
    """Extract parameter names from parameter list"""
    if not params or params.strip() == 'void':
        return []

    names = []
    # Split by comma, but respect parentheses (for function pointers)
    parts = []
    current = []
    depth = 0

    for char in params + ',':
        if char == '(':
            depth += 1
            current.append(char)
        elif char == ')':
            depth -= 1
            current.append(char)
        elif char == ',' and depth == 0:
            parts.append(''.join(current).strip())
            current = []
        else:
            current.append(char)

    for part in parts:
        if not part:
            continue

        # Remove array brackets
        part = re.sub(r'\[.*?\]', '', part)

        # For function pointers like "void (*callback)(int)"
        func_ptr_match = re.search(r'\(\s*\*\s*(\w+)\s*\)', part)
        if func_ptr_match:
            names.append(func_ptr_match.group(1))
            continue

        # Regular parameter: last identifier
        tokens = re.findall(r'\w+', part)
        if tokens:
            # The last token is usually the parameter name
            # But skip type keywords
            type_keywords = {'const', 'struct', 'unsigned', 'signed', 'long', 'short', 'int', 'char', 'float', 'double', 'void'}
            for token in reversed(tokens):
                if token not in type_keywords:
                    names.append(token)
                    break

    return names

def parse_functions(content):
    """Extract function declarations from cleaned content"""
    functions = []

    # Match function declarations: return_type function_name(params);
    # Matches both mlx_* and _mlx_* functions
    pattern = r'\b((?:const\s+)?(?:struct\s+)?[\w\s]+?[\*\s]*)\s+(_?mlx_\w+)\s*\(([^)]*(?:\([^)]*\)[^)]*)*)\)\s*;'

    for match in re.finditer(pattern, content):
        return_type = match.group(1).strip()
        func_name = match.group(2).strip()
        params = match.group(3).strip()

        # Skip if this looks like a variable declaration
        if not params or '{' in params:
            continue

        # Clean up return type
        return_type = ' '.join(return_type.split())

        # Extract parameter names
        param_names = extract_param_names(params)

        functions.append({
            'name': func_name,
            'return_type': return_type,
            'params': params,
            'param_names': param_names
        })

    return functions

def needs_arm64_guard(fn):
    """Check if function needs ARM64 guard for float16/bfloat16 types"""
    name = fn['name']
    ret_type = fn['return_type']
    params = fn['params']
    return ('float16' in name or 'bfloat16' in name or
            'float16_t' in ret_type or 'bfloat16_t' in ret_type or
            'float16_t' in params or 'bfloat16_t' in params)

def generate_wrapper_files(functions, header_path, impl_path):
    """Generate the wrapper header and implementation files"""

    # Generate header file with extern declarations
    with open(header_path, 'w') as f:
        # Header
        f.write("// AUTO-GENERATED by generate_wrappers.py - DO NOT EDIT\n")
        f.write("// This file provides wrapper declarations for MLX-C functions that use dlopen/dlsym\n")
        f.write("//\n")
        f.write("// Strategy: Include mlx.h normally for type definitions, then provide wrapper\n")
        f.write("// functions with w_ prefix that Go code calls directly (e.g., C.w_mlx_add).\n")
        f.write("// Function pointers are defined in mlx_wrappers.c (single compilation unit).\n\n")
        f.write("#ifndef MLX_WRAPPERS_H\n")
        f.write("#define MLX_WRAPPERS_H\n\n")

        f.write("// Include MLX headers for type definitions and original declarations\n")
        f.write("#include \"mlx/c/mlx.h\"\n")
        f.write("#include \"mlx_dynamic.h\"\n")
        f.write("#include <stdio.h>\n\n")

        # Undef all MLX functions to avoid conflicts
        f.write("// Undefine any existing MLX function macros\n")
        for fn in functions:
            f.write(f"#undef {fn['name']}\n")
        f.write("\n")

        # Function pointer extern declarations
        f.write("// Function pointer declarations (defined in mlx_wrappers.c, loaded via dlsym)\n")
        for fn in functions:
            if needs_arm64_guard(fn):
                f.write("#if defined(__aarch64__) || defined(_M_ARM64)\n")
            f.write(f"extern {fn['return_type']} (*w_{fn['name']}_ptr)({fn['params']});\n")
            if needs_arm64_guard(fn):
                f.write("#endif\n")
        f.write("\n")

        # Initialization function declaration
        f.write("// Initialize all function pointers via dlsym (defined in mlx_wrappers.c)\n")
        f.write("int mlx_load_functions(void* handle);\n\n")

        # Wrapper function declarations and inline definitions
        f.write("// Inline wrapper functions that call through function pointers\n")
        f.write("// Go code calls these directly as C.w_mlx_* (no #define redirection needed)\n")
        for fn in functions:
            if needs_arm64_guard(fn):
                f.write("#if defined(__aarch64__) || defined(_M_ARM64)\n")
            f.write(f"static inline {fn['return_type']} w_{fn['name']}({fn['params']}) {{\n")

            # Call through function pointer
            if fn['return_type'] != 'void':
                f.write(f"    return w_{fn['name']}_ptr(")
            else:
                f.write(f"    w_{fn['name']}_ptr(")

            # Pass parameters
            f.write(', '.join(fn['param_names']))
            f.write(");\n")
            f.write("}\n")
            if needs_arm64_guard(fn):
                f.write("#endif\n")
            f.write("\n")

        f.write("#endif // MLX_WRAPPERS_H\n")

    # Generate implementation file with function pointer definitions
    with open(impl_path, 'w') as f:
        f.write("// AUTO-GENERATED by generate_wrappers.py - DO NOT EDIT\n")
        f.write("// This file contains the function pointer definitions and initialization\n")
        f.write("// All function pointers are in a single compilation unit to avoid duplication\n\n")

        f.write("#include \"mlx/c/mlx.h\"\n")
        f.write("#include \"mlx_dynamic.h\"\n")
        f.write("#include <stdio.h>\n")
        f.write("#include <dlfcn.h>\n\n")

        # Function pointer definitions
        f.write("// Function pointer definitions\n")
        for fn in functions:
            if needs_arm64_guard(fn):
                f.write("#if defined(__aarch64__) || defined(_M_ARM64)\n")
            f.write(f"{fn['return_type']} (*w_{fn['name']}_ptr)({fn['params']}) = NULL;\n")
            if needs_arm64_guard(fn):
                f.write("#endif\n")
        f.write("\n")

        # Initialization function
        f.write("// Initialize all function pointers via dlsym\n")
        f.write("int mlx_load_functions(void* handle) {\n")
        f.write("    if (handle == NULL) {\n")
        f.write("        fprintf(stderr, \"MLX: Invalid library handle\\n\");\n")
        f.write("        return -1;\n")
        f.write("    }\n\n")

        for fn in functions:
            if needs_arm64_guard(fn):
                f.write("#if defined(__aarch64__) || defined(_M_ARM64)\n")
            f.write(f"    w_{fn['name']}_ptr = dlsym(handle, \"{fn['name']}\");\n")
            f.write(f"    if (w_{fn['name']}_ptr == NULL) {{\n")
            f.write(f"        fprintf(stderr, \"MLX: Failed to load symbol: {fn['name']}\\n\");\n")
            f.write(f"        return -1;\n")
            f.write(f"    }}\n")
            if needs_arm64_guard(fn):
                f.write("#endif\n")

        f.write("    return 0;\n")
        f.write("}\n")

def main():
    if len(sys.argv) < 3:
        print("Usage: generate_wrappers.py <mlx-c-include-dir> <output-header> [output-impl]", file=sys.stderr)
        sys.exit(1)

    header_dir = sys.argv[1]
    output_header = sys.argv[2]
    # Default implementation file is same name with .c extension
    output_impl = sys.argv[3] if len(sys.argv) > 3 else output_header.replace('.h', '.c')

    print(f"Parsing MLX-C headers from: {header_dir}", file=sys.stderr)

    # Find all headers
    headers = find_headers(header_dir)
    print(f"Found {len(headers)} header files", file=sys.stderr)

    # Parse all headers
    all_functions = []
    seen = set()

    for header in headers:
        try:
            with open(header, 'r') as f:
                content = f.read()

            cleaned = clean_content(content)
            functions = parse_functions(cleaned)

            # Deduplicate
            for func in functions:
                if func['name'] not in seen:
                    seen.add(func['name'])
                    all_functions.append(func)

        except Exception as e:
            print(f"Error parsing {header}: {e}", file=sys.stderr)
            continue

    print(f"Found {len(all_functions)} unique function declarations", file=sys.stderr)

    # Generate wrapper files
    generate_wrapper_files(all_functions, output_header, output_impl)
    print(f"Generated {output_header} and {output_impl} successfully", file=sys.stderr)

if __name__ == '__main__':
    main()
